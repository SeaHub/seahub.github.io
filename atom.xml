<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Words Of Life</title>
  <subtitle>Record the things appearing in my life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-18T15:13:50.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Seahub</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Strategy Pattern</title>
    <link href="http://yoursite.com/2017/02/18/Strategy-Pattern/"/>
    <id>http://yoursite.com/2017/02/18/Strategy-Pattern/</id>
    <published>2017-02-18T12:20:50.000Z</published>
    <updated>2017-02-18T15:13:50.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：利用<code>Objc</code>实现策略模式</p>
<a id="more"></a>
</li>
</ul>
<hr>
<ul>
<li><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>策略模式的介绍<ul>
<li>基础理论</li>
<li>深入理解</li>
<li>UML图</li>
<li>优与劣</li>
</ul>
</li>
<li>策略模式的使用实例</li>
<li>策略模式在系统框架中的应用</li>
</ul>
</li>
</ul>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="策略模式介绍"><a href="#策略模式介绍" class="headerlink" title="策略模式介绍"></a>策略模式介绍</h4><ul>
<li><p>基础理论</p>
<blockquote>
<p>策略模式作为二十三种GoF软件设计模式的其中一种，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。</p>
<p>​                                                                    —— <a href="https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">维基百科</a></p>
</blockquote>
</li>
<li><p>深入理解</p>
<ul>
<li>所谓策略模式，本质就是将需要使用的算法抽象成一个持有的算法对象。在构造函数中选择具体的算法初始化持有的算法对象；在原本使用算法的地方，使用该算法对象调用算法。</li>
<li>根据上述定义，我认为策略模式有以下形式：<ul>
<li>形式：<strong>策略上下文类 + 抽象父类 / 接口 + 具体子类</strong></li>
</ul>
</li>
<li>如果单独使用策略模式，我们会需要在客户类创建具体的策略类对象，这时我们可以将策略模式与简单工厂模式结合使用，减少客户端的判断代码，两者配套食用，味道更佳！</li>
</ul>
</li>
<li><p>UML图</p>
<ul>
<li><img src="/2017/02/18/Strategy-Pattern/UML.png" alt="UML" title="UML">
</li>
</ul>
</li>
<li><p>优与劣</p>
<ul>
<li>优：以相同的形式调用所有的算法，降低算法类与使用算法的类（策略上下文类）的耦合度</li>
<li>劣：扩展时违反开闭原则（OCP，Open Closed Principle），当新增加子类的时候，需要修改策略上下文类</li>
</ul>
</li>
</ul>
<h4 id="策略模式的使用实例"><a href="#策略模式的使用实例" class="headerlink" title="策略模式的使用实例"></a>策略模式的使用实例</h4><ul>
<li><p>下面以一个简单的磁盘调度算法为例（算法实现仅用输出代替），讲述策略模式的应用</p>
<ul>
<li><p>创建父类：在本例中，父类为磁盘调度算法类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  DiskSchedulingAlgorithm.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DiskSchedulingAlgorithm</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//  DiskSchedulingAlgorithm.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"DiskSchedulingAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DiskSchedulingAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run &#123;</div><div class="line">    <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"virtual implement shouldn`t be called by"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>创建继承于父类的子类：本例中，子类为具体的磁盘调度算法类，负责实现具体算法。此处子类重写父类方法，以便合理使用多态</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  CSCANAlgorithm.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"DiskSchedulingAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CSCANAlgorithm</span> : <span class="title">DiskSchedulingAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//  CSCANAlgorithm.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"CSCANAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CSCANAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Do the CSCAN Algorithm"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  SCANAlgorithm.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"DiskSchedulingAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SCANAlgorithm</span> : <span class="title">DiskSchedulingAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//  SCANAlgorithm.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"SCANAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SCANAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Do the SCAN Algorithm"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  SSTFAlgorithm.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"DiskSchedulingAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SSTFAlgorithm</span> : <span class="title">DiskSchedulingAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//  SSTFAlgorithm.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"SSTFAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SSTFAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Do the SSTF Algorithm"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  FCFSAlgorithm.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"DiskSchedulingAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FCFSAlgorithm</span> : <span class="title">DiskSchedulingAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//  FCFSAlgorithm.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"FCFSAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FCFSAlgorithm</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)run &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Do the FCFS Algorithm"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>实现策略上下文类：实现父类中的简单工厂方法，根据类型判断返回的实例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  Context.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"DiskSchedulingAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">DiskSchedulingAlgorithm</span>;</span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">FCFSAlgorithm</span>;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, DiskSchedulingAlgorithmType) &#123;</div><div class="line">    kDiskSchedulingCSCANAlgorithmType,</div><div class="line">    kDiskSchedulingSCANAlgorithmType,</div><div class="line">    kDiskSchedulingFCFSAlgorithmType,</div><div class="line">    kDiskSchedulingSSTFAlgorithmType,</div><div class="line">    kDiskSchedulingDefaultAlgorithmType</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> FCFSAlgorithm DefaultAlgorithmType;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Context</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)schedulingDisk;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span> _Nullable)init;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span> _Nullable)initWithDiskSchedulingAlgorithm:(DiskSchedulingAlgorithmType)type;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) DiskSchedulingAlgorithm *algorithm;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//  Context.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Context.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"CSCANAlgorithm.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"SCANAlgorithm.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"FCFSAlgorithm.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"SSTFAlgorithm.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Context</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithDiskSchedulingAlgorithm:kDiskSchedulingDefaultAlgorithmType];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 简单工厂模式实现</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithDiskSchedulingAlgorithm:(DiskSchedulingAlgorithmType)type &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">switch</span> (type) &#123;</div><div class="line">            <span class="keyword">case</span> kDiskSchedulingCSCANAlgorithmType:</div><div class="line">                _algorithm = [[CSCANAlgorithm alloc] init];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> kDiskSchedulingSCANAlgorithmType:</div><div class="line">                _algorithm = [[SCANAlgorithm alloc] init];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> kDiskSchedulingFCFSAlgorithmType:</div><div class="line">                _algorithm = [[FCFSAlgorithm alloc] init];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> kDiskSchedulingSSTFAlgorithmType:</div><div class="line">                _algorithm = [[SSTFAlgorithm alloc] init];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> kDiskSchedulingDefaultAlgorithmType:</div><div class="line">                _algorithm = [[DefaultAlgorithmType alloc] init];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)schedulingDisk &#123;</div><div class="line">    [_algorithm run];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>至此，策略模式实现完毕</p>
</li>
</ul>
</li>
</ul>
<h4 id="策略模式在系统框架中的应用"><a href="#策略模式在系统框架中的应用" class="headerlink" title="策略模式在系统框架中的应用"></a>策略模式在系统框架中的应用</h4><ul>
<li>以下内容存有不确定性，倘若有误，劳烦告知</li>
</ul>
<ul>
<li><p>NSArray</p>
<ul>
<li><p>我们查阅<code>NSArray</code> API文档时会发现，有下面这一段话</p>
<blockquote>
<p>Remember that <code>NSArray</code> is the public interface for a class cluster and what this entails for your subclass. You must provide the storage for your subclass and implement the primitive methods that directly act on that storage.</p>
<p>​                                                    —— <a href="https://developer.apple.com/reference/foundation/nsarray" target="_blank" rel="external">NSArray API Reference</a></p>
</blockquote>
</li>
<li><p>与<code>NSString</code>类一样，<code>NSArray</code>亦是一个类簇类。对于类簇类而言，如果我们想要继承它，我们需要处理一系列较为复杂的问题。当我们需要使用<code>NSArray</code>的行为时（比如在<code>NSArray</code>之上实现一个栈结构），我们更好地方法是持有<code>NSArray</code>，而非继承。我们可以将<code>NSArray</code>当作我们其中一个策略，然后使用该策略去处理问题。</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>总结：本文简述了策略模式的理论以及实践。我认为，策略模式本质是<strong>持有对象，并使用该对象去解决问题</strong>。我们应该去把握好这个本质。</li>
<li>本文代码下载<ul>
<li><a href="https://github.com/SeaHub/CodeSample/tree/master/Code/StrategyPattern" target="_blank" rel="external">示例代码</a></li>
<li>运行环境：Xcode 8.2.1 (8C1002)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Last Edited：2017.2.18</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：利用&lt;code&gt;Objc&lt;/code&gt;实现策略模式&lt;/p&gt;
    
    </summary>
    
      <category term="Objc" scheme="http://yoursite.com/categories/Objc/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/Objc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
      <category term="ObjC" scheme="http://yoursite.com/tags/ObjC/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Simple Factory Pattern</title>
    <link href="http://yoursite.com/2017/02/17/Simple-Factory-Pattern/"/>
    <id>http://yoursite.com/2017/02/17/Simple-Factory-Pattern/</id>
    <published>2017-02-17T15:04:52.000Z</published>
    <updated>2017-02-18T12:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：利用<code>Objc</code>实现简单工厂模式</p>
<a id="more"></a>
</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>最近重阅设计模式相关的书籍，阅读时无不感慨前人的智慧，希望以此文为头，记下与设计模式相关的笔记</li>
</ul>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>简单工厂模式的介绍<ul>
<li>基础理论</li>
<li>深入理解</li>
<li>UML图</li>
<li>优与劣</li>
</ul>
</li>
<li>简单工厂模式的使用实例</li>
<li>简单工厂模式在系统框架中的应用</li>
</ul>
<hr>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="简单工厂模式介绍"><a href="#简单工厂模式介绍" class="headerlink" title="简单工厂模式介绍"></a>简单工厂模式介绍</h4><ul>
<li>基础理论<blockquote>
<p>简单工厂模式是属于<strong>创建型</strong>模式，又叫做<strong>静态工厂方法</strong>（Static Factory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现</p>
<p>​                                                                    —— <a href="http://baike.baidu.com/link?url=MuiHpZoo9DF58mVTz7UMoEyEiySMqoxSmDc3aN2ywj-SWAPjcqPowT-4YOE0V__UgiLM4QjQ7UTxbgJvhGKt79VHCeuNpRqXeHN3rG4jVHi-EJDJ8PMzcb_fqY9ijo6rZfFxdoLEM7IO5aPz7Vvm5_" target="_blank" rel="external">百度百科</a></p>
</blockquote>
</li>
<li>深入理解<ul>
<li>所谓简单工厂模式，本质就是<strong>根据传入的参数进行判断，动态选择不同的子类进行初始化</strong>。而为了方便对外使用，我们只暴露一个最最简单易用的父类 / 接口 / 工厂类。</li>
<li>根据上述定义，我认为简单工厂模式有以下两种：<ul>
<li>形式I：<strong>抽象父类 + 具体子类</strong>（静态工厂方法定义在抽象父类中，该形式又被称作<strong>类簇模式</strong>，见UML图上半部分）</li>
<li>形式II：<strong>工厂类 + 抽象父类 / 接口 + 具体子类</strong>（静态工厂方法定义在工厂类中，见UML图下半部分）</li>
</ul>
</li>
</ul>
</li>
<li>UML图<ul>
<li><img src="/2017/02/17/Simple-Factory-Pattern/UML.png" alt="UML" title="UML"></li>
</ul>
</li>
<li>优与劣<ul>
<li>优：隐藏了实现类，用户在使用的时候无需知道对象如何构建的，对外仅暴露了必要的接口。 </li>
<li>劣：扩展时违反开闭原则（OCP，Open Closed Principle），当新增加子类的时候，需要修改在抽象父类 / 工厂类中的静态工厂方法。</li>
</ul>
</li>
</ul>
<h4 id="简单工厂模式的使用实例"><a href="#简单工厂模式的使用实例" class="headerlink" title="简单工厂模式的使用实例"></a>简单工厂模式的使用实例</h4><ul>
<li><p>下面以一个简单的二元加减乘除计算器为例，讲述简单工厂模式的应用</p>
<ul>
<li><p>创建父类：在本例中，父类为基础二元算术运算类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Operation.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, OperationType) &#123;</div><div class="line">    OperationTypeAdd,</div><div class="line">    OperationTypeSub,</div><div class="line">    OperationTypeMul,</div><div class="line">    OperationTypeDiv,</div><div class="line">    OperationTypeDefault</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span> OperandType;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Operation</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)operationWithType:(OperationType)type;</div><div class="line">- (OperandType)calculate;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readwrite</span>) OperandType operandA;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readwrite</span>) OperandType operandB;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>简单实现父类：本例采用<strong>形式I</strong>的简单工厂模式，故工厂方法放在父类中</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Operation.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Operation.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Operation</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)operationWithType:(OperationType)type &#123;</div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="keyword">case</span> OperationTypeAdd:</div><div class="line">            <span class="keyword">return</span> [[OperationAdd alloc] init];</div><div class="line">        <span class="keyword">case</span> OperationTypeSub:</div><div class="line">            <span class="keyword">return</span> [[OperationSub alloc] init];</div><div class="line">        <span class="keyword">case</span> OperationTypeMul:</div><div class="line">            <span class="keyword">return</span> [[OperationMul alloc] init];</div><div class="line">        <span class="keyword">case</span> OperationTypeDiv:</div><div class="line">            <span class="keyword">return</span> [[OperationDiv alloc] init];</div><div class="line">        <span class="keyword">case</span> OperationTypeDefault:</div><div class="line">            <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (OperandType)calculate &#123;</div><div class="line">    <span class="comment">// virtual implement</span></div><div class="line">    <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"virtual implement shouldn`t be called by"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>创建继承于父类的子类：本例中，子类为具体的操作类，负责实现操作运算。此处子类重写父类方法，以便合理使用多态</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OperationAdd.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Operation.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OperationAdd</span> : <span class="title">Operation</span></span></div><div class="line"></div><div class="line">- (OperandType)calculate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="comment">// OperationAdd.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"OperationAdd.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OperationAdd</span></span></div><div class="line"></div><div class="line">- (OperandType)calculate &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.operandA + <span class="keyword">super</span>.operandB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OperationSub.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Operation.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OperationSub</span> : <span class="title">Operation</span></span></div><div class="line"></div><div class="line">- (OperandType)calculate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="meta">#import <span class="meta-string">"OperationSub.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">// OperationSub.m</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OperationSub</span></span></div><div class="line"></div><div class="line">- (OperandType)calculate &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.operandA - <span class="keyword">super</span>.operandB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OperationMul.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Operation.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OperationMul</span> : <span class="title">Operation</span></span></div><div class="line"></div><div class="line">- (OperandType)calculate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// OperationSub.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"OperationSub.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OperationSub</span></span></div><div class="line"></div><div class="line">- (OperandType)calculate &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.operandA - <span class="keyword">super</span>.operandB;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OperationDiv.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Operation.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OperationDiv</span> : <span class="title">Operation</span></span></div><div class="line"></div><div class="line">- (OperandType)calculate;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// OperationDiv.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"OperationDiv.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OperationDiv</span></span></div><div class="line"></div><div class="line">- (OperandType)calculate &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.operandB != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.operandA / <span class="keyword">super</span>.operandB;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">NSIntegerMax</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>实现简单工厂方法：实现父类中的简单工厂方法，根据类型判断返回的实例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  Operation.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"OperationAdd.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"OperationSub.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"OperationMul.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"OperationDiv.h"</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)operationWithType:(OperationType)type &#123;</div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="keyword">case</span> OperationTypeAdd:</div><div class="line">            <span class="keyword">return</span> [[OperationAdd alloc] init];</div><div class="line">        <span class="keyword">case</span> OperationTypeSub:</div><div class="line">            <span class="keyword">return</span> [[OperationSub alloc] init];</div><div class="line">        <span class="keyword">case</span> OperationTypeMul:</div><div class="line">            <span class="keyword">return</span> [[OperationMul alloc] init];</div><div class="line">        <span class="keyword">case</span> OperationTypeDiv:</div><div class="line">            <span class="keyword">return</span> [[OperationDiv alloc] init];</div><div class="line">        <span class="keyword">case</span> OperationTypeDefault:</div><div class="line">            <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>至此，简单工厂模式实现完毕</p>
</li>
</ul>
</li>
</ul>
<h4 id="简单工厂模式在系统框架中的应用"><a href="#简单工厂模式在系统框架中的应用" class="headerlink" title="简单工厂模式在系统框架中的应用"></a>简单工厂模式在系统框架中的应用</h4><ul>
<li><p>NSString</p>
<ul>
<li><p>我们查阅<code>NSString</code> API文档时会发现，有下面这一段话</p>
<blockquote>
<p>The objects you create using <code>NSString</code> and <code>NSMutableString</code> are referred to as string objects (or, when no confusion will result, merely as strings). The term C string refers to the standard <code>char *</code> type. Because of the nature of class clusters, string objects aren’t actual instances of the <code>NSString</code> or <code>NSMutableString</code> classes but of one of their private subclasses. Although a string object’s class is private, its interface is public, as declared by these abstract superclasses, <code>NSString</code> and <code>NSMutableString</code>. The string classes adopt the <a href="https://developer.apple.com/reference/foundation/nscopying" target="_blank" rel="external"><code>NSCopying</code></a> and <a href="https://developer.apple.com/reference/foundation/nsmutablecopying" target="_blank" rel="external"><code>NSMutableCopying</code></a> protocols, making it convenient to convert a string of one type to the other.</p>
<p>​                                                    —— <a href="https://developer.apple.com/reference/foundation/nsstring" target="_blank" rel="external">NSString API Reference</a></p>
</blockquote>
</li>
<li><p><code>NSString</code>类是一个类簇类。所谓类簇类，实际上是一个隐含着许多私有类的类。一般类簇类都带有工厂方法。我们查看<code>NSString</code>头文件，可以发现许多工厂方法（见下）。其本质亦是简单工厂模式，类簇类的私有类放在父类<code>.m</code>文件中。然后其利用传入的参数作为判断标准，生成私有类的实例，并作为<code>NSString</code>实例返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)string;</div><div class="line">+ (<span class="keyword">instancetype</span>)stringWithString:(<span class="built_in">NSString</span> *)string;</div><div class="line">+ (<span class="keyword">instancetype</span>)stringWithCharacters:(<span class="keyword">const</span> <span class="keyword">unichar</span> *)characters length:(<span class="built_in">NSUInteger</span>)length;</div><div class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)stringWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)nullTerminatedCString;</div><div class="line">+ (<span class="keyword">instancetype</span>)stringWithFormat:(<span class="built_in">NSString</span> *)format, ... <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">+ (<span class="keyword">instancetype</span>)localizedStringWithFormat:(<span class="built_in">NSString</span> *)format, ... <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">1</span>,<span class="number">2</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>实际上，在系统框架中许多类都是以类簇的方式实现的，而以这种方式实现的类一般又含有类簇形式的简单工厂方法，因此类簇模式与简单工厂模式可谓是相得益彰。</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>总结：本文简述了简单工厂模式的理论以及实践。我认为，简单工厂模式本质是<strong>根据传入的参数进行判断，动态选择不同的子类进行初始化</strong>。只要把握好这一本质，便能理清简单工厂模式。</li>
<li>本文代码下载<ul>
<li><a href="https://github.com/SeaHub/CodeSample/tree/master/Code/SimpleFactoryPattern" target="_blank" rel="external">示例代码</a></li>
<li>运行环境：Xcode 8.2.1 (8C1002)</li>
</ul>
</li>
<li>推荐阅读<ul>
<li><a href="http://www.jianshu.com/p/c60d9ffcde4b" target="_blank" rel="external">类簇(class cluster) by 摸鸡校尉</a></li>
<li><a href="http://blog.sunnyxx.com/2014/12/18/class-cluster/" target="_blank" rel="external">从NSArray看类簇 by sunnyxx</a></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Last Edited：2017.2.17</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：利用&lt;code&gt;Objc&lt;/code&gt;实现简单工厂模式&lt;/p&gt;
    
    </summary>
    
      <category term="Objc" scheme="http://yoursite.com/categories/Objc/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/Objc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
      <category term="ObjC" scheme="http://yoursite.com/tags/ObjC/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Load And Initialization Methods</title>
    <link href="http://yoursite.com/2017/01/17/Load-And-Initialization-Methods/"/>
    <id>http://yoursite.com/2017/01/17/Load-And-Initialization-Methods/</id>
    <published>2017-01-17T14:45:01.000Z</published>
    <updated>2017-01-22T13:04:03.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：浅谈<code>NSObject</code>中的<code>load</code>方法与<code>initialize</code>方法</p>
<a id="more"></a>
</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>谈到<code>NSObject</code>根类，有朋友可能便会立即想到这两个方法，这两个方法究竟是什么？它们有什么区别，又有什么共同点呢？希望下文能够帮各位朋友重温<code>load</code>方法与<code>initialize</code>方法的要点。</li>
</ul>
<h2 id="void-load"><a href="#void-load" class="headerlink" title="+ (void)load;"></a>+ (void)load;</h2><ul>
<li><p>在运行时，涉及<code>load</code>的方法，大概调用过程如下图</p>
  <img src="/2017/01/17/Load-And-Initialization-Methods/load.png" alt="Load Photo" title="Load Photo">
</li>
<li><p><code>load</code>方法在程序中的调用时间段：在App启动加载时调用</p>
<ol>
<li>程序依赖的动态链接库加载进内存</li>
<li>加载可执行文件的所有符号、代码</li>
<li>运行时解析被编译过的符号代码，遍历所有类与分类，按继承关系依次调用类与分类的load方法<ul>
<li><code>load</code>方法一般在类/分类添加到运行时环境时调用，一般在<code>application:willFinishLaunchingWithOptions:</code>调用之前</li>
</ul>
</li>
</ol>
</li>
<li><p><code>Xcode - Targets - Build Phases - Complie Sources</code>中的顺序为默认<code>load</code>方法的调用顺序，但并非最终的调用顺序，因为被依赖的类会优先调用<code>load</code>方法。比如子类B是父类A的子类，当把子类B放在<code>Complie Sources</code>的第一个文件时，编译运行后，会发现首先是父类的<code>load</code>方法先调用，然后再是子类的<code>load</code>方法调用，详细调用顺序请见下文</p>
</li>
<li><p><code>load</code>方法中会自动加锁，保证线程安全</p>
</li>
<li><p>调用顺序：<strong>依赖的类会先调用，即调用子类时，会先调用父类；分类最后调用，不会覆盖<code>load</code>方法</strong></p>
<ul>
<li>简析：因为<code>load</code>方法在运行时并不是通过消息发送(<code>objc_msgSend</code>)，而是通过函数指针来实现的。所以对于一个有继承关系的类，若子类中的<code>load</code>方法为空实现，则父类的<code>load</code>方法除因依赖问题被调用一次外，不会再次被调用。同理，因为不是走消息发送的原因，所以如果在分类中重写<code>load</code>方法，分类中的<code>load</code>方法并不会像其他方法一样覆盖原类的<code>load</code>方法，而是在原类<code>load</code>方法执行后执行</li>
<li>例子A：假设分类B+C是子类B的分类，分类含有<code>load</code>方法。而子类B是父类A的子类，在<code>AppDelegate.m</code>中创建一个子类B对象，则load方法调用顺序如下：<ol>
<li>调用父类A的<code>load</code>方法</li>
<li>调用子类B的<code>load</code>方法</li>
<li>调用分类B+C的<code>load</code>方法</li>
</ol>
</li>
</ul>
</li>
<li><p>一般应用场景</p>
<ul>
<li><a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">在<code>load</code>方法中实现<code>method_swizzle</code> - @Glow 技术团队博客</a></li>
<li><a href="http://blog.sunnyxx.com/2015/03/09/notification-once/" target="_blank" rel="external">瘦身<code>AppDelegate</code> - @sunnyxx的技术博客</a></li>
<li>用于判断类/分类是否正确的加载</li>
</ul>
</li>
</ul>
<h2 id="void-initialize"><a href="#void-initialize" class="headerlink" title="+ (void)initialize;"></a>+ (void)initialize;</h2><ul>
<li><p>在运行时中，涉及<code>initialize</code>的方法，大概调用过程如下图</p>
  <img src="/2017/01/17/Load-And-Initialization-Methods/initialize.png" alt="Initialize Photo" title="Initialize Photo">
</li>
<li><p><code>initialize</code>方法在程序中的调用时间段：第一次主动调用当前类时，即<code>initialize</code>方法永远是类收到的第一个消息。注意，上文提及的load方法因为是通过函数指针调用，并不是走消息发送的途径，所以尽管<code>load</code>方法在<code>initialize</code>方法调用前调用，但<code>load</code>方法依然不能称作第一个消息</p>
</li>
<li><p><code>initialize</code>方法在线程安全的环境中执行，即只有执行<code>initialize</code>的那个线程可以操作类/类实例，其他线程都会被阻塞，等待<code>initialize</code>方法执行完</p>
</li>
<li><p>调用顺序：<strong>依赖的类会先调用，即调用子类时，会先调用父类；当子类空实现时，会再次调用父类方法；分类会覆盖<code>load</code>方法</strong></p>
<ul>
<li><p>简析：因为<code>initialize</code>方法在运行时是通过消息发送(<code>objc_msgSend</code>)来实现的。所以对于一个有继承关系的类，如果子类中的<code>initialize</code>方法为空实现，则父类的<code>initialize</code>方法会被自动调用（等价于我们系统帮我们默认在空实现中写了<code>[super initialize]</code>）。同理，因为消息发送的原因，所以子类分类如果分类中重写<code>initialize</code>方法，分类中的<code>initialize</code>方法会像其他方法一样覆盖子类的<code>initialize</code>方法。</p>
</li>
<li><p>例子B：假设子类B是父类A的子类，B中<code>initialize</code>方法为空实现，在<code>AppDelegate.m</code>中创建一个子类B对象，则<code>initialize</code>方法调用顺序如下：</p>
<ol>
<li>调用父类A的<code>initialize</code>方法</li>
<li>再次调用父类A的<code>initialize</code>方法</li>
<li>调用子类B自身的<code>initialize</code>方法</li>
</ol>
</li>
<li><p>例子B补充：由于在父类A中，<code>initialize</code>方法会被调用两次，可在父类A使用以下代码，避免父类A的<code>initialize</code>方法多次执行初始化代码：</p>
<img src="/2017/01/17/Load-And-Initialization-Methods/codeA.png" alt="codeA Photo" title="codeA Photo">
</li>
<li><p>例子C：假设分类B+C是子类B的分类，分类含有<code>initialize</code>方法，但该方法不含<code>[super initialize]</code>。而子类B是父类A的子类，子类B中<code>initialize</code>方法为非空实现，在<code>AppDelegate.m</code>中创建一个子类B对象，则<code>initialize</code>方法调用顺序如下：</p>
<ol>
<li>调用父类A的<code>initialize</code>方法</li>
<li>调用分类B+C的<code>initialize</code>方法（注意，由于我们没写<code>[super initialize]</code>，所以仅调用一次父类<code>initialize</code>方法，系统不会自动为我们增加该语句）</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>一般应用场景</p>
<ul>
<li><p>用于初始化无法直接初始化的全局状态的<code>static</code>变量，如下，<code>NSArray</code>无法直接初始化，只能在<code>initialize</code>方法中对其进行初始化</p>
 <img src="/2017/01/17/Load-And-Initialization-Methods/codeB.png" alt="codeB Photo" title="codeB Photo">
</li>
</ul>
<p>​</p>
</li>
</ul>
<h2 id="对比表格"><a href="#对比表格" class="headerlink" title="对比表格"></a>对比表格</h2><table>
<thead>
<tr>
<th style="text-align:center">对比点</th>
<th style="text-align:center"><code>load</code>方法</th>
<th style="text-align:center"><code>initialize</code>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">是否所有类都会调用</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">什么情况下会被调用</td>
<td style="text-align:center">只要类所在的文件夹被引用</td>
<td style="text-align:center">只要类的方法被调用</td>
</tr>
<tr>
<td style="text-align:center">什么时候调用</td>
<td style="text-align:center">被添加到运行时环境时</td>
<td style="text-align:center">收到消息时/永远不调用</td>
</tr>
<tr>
<td style="text-align:center">在<code>main</code>方法前/后调用</td>
<td style="text-align:center">前</td>
<td style="text-align:center">后</td>
</tr>
<tr>
<td style="text-align:center">调用时运行时环境</td>
<td style="text-align:center">脆弱的运行时环境，自动释放池尚未建立</td>
<td style="text-align:center">完整的运行时环境</td>
</tr>
<tr>
<td style="text-align:center">调用本质</td>
<td style="text-align:center">函数指针调用</td>
<td style="text-align:center">消息发送(<code>objc_msgSend</code>)</td>
</tr>
<tr>
<td style="text-align:center">系统是否最多调用一次</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否，父类的可能被执行多次</td>
</tr>
<tr>
<td style="text-align:center">空实现时，自动调用父类实现</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">父类、子类、分类的调用顺序</td>
<td style="text-align:center">父类 -&gt; 子类 -&gt; 分类</td>
<td style="text-align:center">父类 -&gt; 分类/子类</td>
</tr>
<tr>
<td style="text-align:center">是否线程安全</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<h2 id="禁忌点"><a href="#禁忌点" class="headerlink" title="禁忌点"></a>禁忌点</h2><ul>
<li><code>load</code>方法<ul>
<li>不要在<code>load</code>方法中滥用其他类<ul>
<li>这是因为我们无法判断各个类的载入顺序，有可能会导致依赖环</li>
</ul>
</li>
<li>不要在<code>load</code>方法中滥用需要<code>Autoreleasepool</code>的方法，如<code>[NSArray array]</code>等方法<ul>
<li>这是因为此时运行时环境脆弱，<code>Autoreleasepool</code>尚未加载，如果确实要使用，需使用<code>@Autoreleasepool</code>代码块将其包围</li>
</ul>
</li>
<li>不要在<code>load</code>方法中包含复杂的代码，即使用时不能重度依赖该方法<ul>
<li>这是因为过于复杂的<code>load</code>方法会阻塞线程，导致程序无响应</li>
</ul>
</li>
<li>不要在<code>load</code>方法中包含等待锁/调用可能会加锁的方法<ul>
<li>这是因为我们无法判断各个类的载入顺序，有可能会导致死锁/饥饿</li>
</ul>
</li>
</ul>
</li>
<li><code>initialize</code>方法<ul>
<li>绝不应该通过代码直接调用<code>initialize</code>方法<ul>
<li>这是因为我们应该保证<code>initialize</code>方法由系统调用，保证其仅调用一次</li>
</ul>
</li>
<li>不要在<code>initialize</code>方法中包含复杂的代码，即使用时不能重度依赖该方法<ul>
<li>这是因为其有可能阻塞UI线程</li>
</ul>
</li>
<li>不要在<code>initialize</code>方法中滥用其他类<ul>
<li>这是因为在本类还没有完全初始化的时候，却又被自身调用的类调用了，即有可能会导致依赖环</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><code>load</code>方法与<code>initialize</code>方法可以<code>main</code>方法为分界线，将调用顺序划分如下图，注意，其中<code>initialize</code>方法也有可能不调用</p>
  <img src="/2017/01/17/Load-And-Initialization-Methods/main.png" alt="Main Photo" title="Main Photo">
</li>
<li><p><code>load</code>在运行时通过函数指针调用，<code>initialize</code>方法通过消息发送调用，这直接导致了他们之间的差异</p>
</li>
</ul>
<hr>
<ul>
<li>本文用到的代码下载<ul>
<li><a href="https://github.com/SeaHub/CodeSample/tree/master/Code/DeepingLoadAndInitialize" target="_blank" rel="external"><strong>Github Repo - DeepingLoadAndInitialize</strong></a></li>
<li><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="external"><strong>Github Repo - ObjC-Runtime by @RetVal</strong></a></li>
<li>运行环境：Xcode 8.2.1(8C1002)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Last Edited：2016.1.17</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：浅谈&lt;code&gt;NSObject&lt;/code&gt;中的&lt;code&gt;load&lt;/code&gt;方法与&lt;code&gt;initialize&lt;/code&gt;方法&lt;/p&gt;
    
    </summary>
    
      <category term="ObjC" scheme="http://yoursite.com/categories/ObjC/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/ObjC/iOS/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
      <category term="ObjC" scheme="http://yoursite.com/tags/ObjC/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Top-Level Const And Low-Level Const</title>
    <link href="http://yoursite.com/2016/12/05/Top-Level-Const-And-Low-Level-Const/"/>
    <id>http://yoursite.com/2016/12/05/Top-Level-Const-And-Low-Level-Const/</id>
    <published>2016-12-05T04:41:52.000Z</published>
    <updated>2016-12-05T05:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：ObjC Const 小坑总结</p>
<a id="more"></a>
</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>记得刚学ObjC的时候，总是被顶层<code>const</code>和底层<code>const</code>搞的头晕晕的（也可能是我本人比较笨的原因吧:]）。谨以此文，记录我踏过的坑，同时也希望为后人扫个雷</li>
</ul>
<hr>
<h2 id="先谈C-顶层const与底层const"><a href="#先谈C-顶层const与底层const" class="headerlink" title="先谈C++ 顶层const与底层const"></a>先谈C++ 顶层const与底层const</h2><ul>
<li><p>最早了解到<code>const</code>相关的话题时，是在阅读C++ Primer一书时，里面提到的两个概念</p>
<blockquote>
<p>顶层const：表示指针本身是个常量</p>
<p>底层const：表示指针所指的对象是一个常量</p>
</blockquote>
</li>
<li><p>在C++中，由顶层<code>const</code>与底层<code>const</code> + 指针类型，又衍生了两个概念</p>
<ul>
<li>常量指针：顶层<code>const</code>指针，即指针不可变，不能再指向其他元素，但指针指向的元素自身可变</li>
<li>指针常量：底层<code>const</code>指针，即指针可变，但指针指向的元素自身不可变</li>
</ul>
</li>
<li><p>概念本身是很简单的，但是上了代码之后，我们能认清下面哪个是顶层，哪个是底层吗?</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通变量</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</div><div class="line">    </div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> ptrA = &amp;a;</div><div class="line"><span class="comment">// 顶层const，ptrA为常量指针，ptrA不能再指向其他变量</span></div><div class="line"><span class="comment">// ==== Error Code ====</span></div><div class="line"><span class="comment">// ptrA = &amp;b;</span></div><div class="line"><span class="comment">// ==== Allow Code ====</span></div><div class="line">*ptrA = <span class="number">2</span>;</div><div class="line">    </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptrB = &amp;b;</div><div class="line"><span class="comment">// 底层const, ptrB为指针常量，ptrB指向的b不能改变</span></div><div class="line"><span class="comment">// ==== Error Code ====</span></div><div class="line"><span class="comment">// *ptrB = 2;</span></div><div class="line"><span class="comment">// ==== Allow Code ====</span></div><div class="line">ptrB = &amp;a;</div><div class="line">    </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">10</span>;</div><div class="line"><span class="comment">// 底层const，ci本身不能再改变</span></div><div class="line"><span class="comment">// ==== Error Code ====</span></div><div class="line"><span class="comment">// ci = 11;</span></div><div class="line">    </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> ptrC = ptrB;</div><div class="line"><span class="comment">// 左边为底层const，右边为顶层const，ptrC既是常量指针，又是指针常量</span></div><div class="line"><span class="comment">// ==== Error Code ====</span></div><div class="line"><span class="comment">// ptrC = ptrA;</span></div><div class="line"><span class="comment">// ==== Error Code ====</span></div><div class="line"><span class="comment">// *ptrC = 2;</span></div><div class="line">    </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rA = a;</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> &amp;rB = b;</div><div class="line"><span class="comment">// 用于声明引用的都是底层const，这是因为引用本身不能二次赋值</span></div><div class="line"><span class="comment">// ==== Error Code ====</span></div><div class="line"><span class="comment">// rA = 2;</span></div><div class="line"><span class="comment">// rB = 2;</span></div><div class="line">    </div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> *ptrD = ptrB;</div><div class="line"><span class="comment">// 底层const，ptrD是指针常量，ptrD指向的b本身不能改变</span></div><div class="line"><span class="comment">// ==== Error Code ====</span></div><div class="line"><span class="comment">// *ptrD = 11;</span></div><div class="line"><span class="comment">// ==== Allow Code ====</span></div><div class="line">ptrD = ptrA;</div></pre></td></tr></table></figure>
<ul>
<li><p>图解</p>
<img src="/2016/12/05/Top-Level-Const-And-Low-Level-Const/cpp_const.png" alt="cpp_const" title="cpp_const">
<ul>
<li>图解标注<ul>
<li>空心箭头表示指向的对象值可变 &lt;=&gt; 实心箭头表示指向的对象值不可变</li>
<li>虚线表示指向对象这种关系可变 &lt;=&gt; 实心箭头表示指向对象这种关系固定了</li>
</ul>
</li>
</ul>
</li>
<li><p>小总结</p>
<ul>
<li>指针与<code>const</code><ul>
<li><code>const</code>靠近指针符号<ul>
<li>=&gt; <code>const</code>为顶层<code>const</code>，指针为常量指针，指向关系不能变</li>
</ul>
</li>
<li>const两边在中间或靠近数据类型<ul>
<li>=&gt; <code>const</code>为底层<code>const</code>，指针为指针常量，指向关系可变，指向元素不可变</li>
</ul>
</li>
</ul>
</li>
<li>引用与<code>const</code><ul>
<li>引用变量：因为引用不能二次赋值，所以只能声明底层<code>const</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="再谈ObjC-const"><a href="#再谈ObjC-const" class="headerlink" title="再谈ObjC const"></a>再谈ObjC const</h2><ul>
<li><p>const在ObjC中的用途</p>
<ul>
<li><p>代替<code>#define</code>声明常量，保证编译器有类型检测（见下图）</p>
<img src="/2016/12/05/Top-Level-Const-And-Low-Level-Const/defineAconst.png" alt="define VS const.png" title="define VS const.png">
</li>
<li><p>我们希望能够保证kGoodbyeString不被修改，如果我们不去考虑底层<code>const</code>/顶层<code>const</code>的问题，我们可以直接使用两个<code>const</code>来让他达到和#define一样的效果</p>
</li>
</ul>
</li>
<li><p>讨论</p>
<ul>
<li><p>ObjC与C++的<code>const</code>用法是否一样？很幸运，是的。下述三种<code>const</code>用法均与C++的用法一样</p>
<img src="/2016/12/05/Top-Level-Const-And-Low-Level-Const/normalConst.png" alt="normal" title="normal">
</li>
<li><p>那我们要讨论的是什么呢？我们要讨论的是，当指针遇上对象，我们究竟需要什么样的<code>const</code>来达到<code>#define</code>的效果</p>
<ul>
<li><p>图解 - 开始</p>
<img src="/2016/12/05/Top-Level-Const-And-Low-Level-Const/objc_const_start.png" alt="start" title="start">
<ul>
<li>图解标注<ul>
<li>在ObjC中，我们把@”xx”称作字符串常量，在ObjC中，实际上有一个字符串常量池，我们可以把它看作一个集合。用到的字符串都会出现在这里，且只出现一次。然后指针指向这块内存，以降低内存消耗。所以，我们代码中的constStringA、constStringB、constStringC实际上都是指向了这块内存。其中，constStringA、constStringB是指针常量，constStringC是常量指针</li>
<li>空心箭头表示指向的对象值可变 &lt;=&gt; 实心箭头表示指向的对象值不可变</li>
<li>虚线表示指向对象这种关系可变 &lt;=&gt; 实心箭头表示指向对象这种关系固定了</li>
</ul>
</li>
</ul>
</li>
<li><p>接下来，我们来执行一段代码，再来看看状态</p>
<img src="/2016/12/05/Top-Level-Const-And-Low-Level-Const/code.png" alt="code" title="code">
</li>
<li><p>图解 - 执行代码后</p>
<img src="/2016/12/05/Top-Level-Const-And-Low-Level-Const/objc_const_end.png" alt="end" title="end">
<ul>
<li>图解标注<ul>
<li>执行代码后，实际上改变的是指针的指向，而非内存里字符串常量的值</li>
<li>空心箭头表示指向的对象值可变 &lt;=&gt; 实心箭头表示指向的对象值不可变</li>
<li>虚线表示指向对象这种关系可变 &lt;=&gt; 实心箭头表示指向对象这种关系固定了</li>
<li>从图上看，我们可以知道，对于字符串常量对象而言，因为字符串本身就不可变了，我们希望指向他的指针的指向关系不能改变。所以我们需要使用的应该是常量指针（constStringC）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>上述部分只是针对字符串常量对象而言，针对字符串常量，我们如果想要达到<code>#define</code>的效果，需要使用的应该是常量指针（即顶层<code>const</code>）</p>
</li>
<li><p>由于在ObjC中，大部分对象都会涉及到指针，所以对于对象而言，我们首先要使用顶层<code>const</code>。其次我们还要研究对象本身是否可变，如果本身可变，则要用底层<code>const</code></p>
</li>
</ul>
</li>
<li><p>小总结</p>
<ul>
<li>在ObjC中使用<code>const</code>代替<code>#define</code>中最简单的用法：使用两个<code>const</code>来限定</li>
<li>如果不想使用两个<code>const</code>，我们则需研究对象本身是否可变，如果本身可变，则要用底层<code>const</code> + 顶层<code>const</code>；否则用一个顶层<code>const</code>即可</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>本文代码下载<ul>
<li><a href="https://github.com/SeaHub/CodeSample/tree/master/Code/CppLearningConst" target="_blank" rel="external"><strong>Github Repo - CppLearningConst</strong></a></li>
<li><a href="https://github.com/SeaHub/CodeSample/tree/master/Code/ObjCLearningConst" target="_blank" rel="external"><strong>Github Repo - ObjCLearningConst</strong></a></li>
<li>运行环境：Xcode 8.1(8B62)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Last Edited：2016.12.5</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：ObjC Const 小坑总结&lt;/p&gt;
    
    </summary>
    
      <category term="ObjC" scheme="http://yoursite.com/categories/ObjC/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
      <category term="ObjC" scheme="http://yoursite.com/tags/ObjC/"/>
    
  </entry>
  
  <entry>
    <title>UIResponder, Weak Or Strong?</title>
    <link href="http://yoursite.com/2016/11/22/UIResponder,%20Weak%20Or%20Strong/"/>
    <id>http://yoursite.com/2016/11/22/UIResponder, Weak Or Strong/</id>
    <published>2016-11-22T14:47:39.000Z</published>
    <updated>2016-11-23T04:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：一个小问题引起的两三思</p>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></li>
<li><p>一朋友在看视频学习时敲下以下代码（涉及到的主要代码如下），然后问了我一个小问题，问题是：”为什么要有weakLabel指向aLabel?”。</p>
<img src="/2016/11/22/UIResponder,%20Weak%20Or%20Strong/defaultCode.png" alt="DefaultCode" title="DefaultCode">
</li>
<li><p>我给他的答案比较简单：”因为新建的aLabel可能在后续的地方用到，所以使用weakLabel指向，这样做主要是方便以后访问”</p>
</li>
<li><p>问题本该到此就结束了，本篇文章也许就不复存在。然而，后来朋友走后，看到属性的weak定义，自己又产生了一些后续的思考：”我们使用属性指向UIResponder控件的时候 ，应该是weak还是strong呢？” 针对这个问题，我认为，应该有以下几种情况可以用作讨论。以下纯属个人之见，如有不对，还望指正</p>
</li>
</ul>
<hr>
<h2 id="Using-Interface-Builder"><a href="#Using-Interface-Builder" class="headerlink" title="Using Interface Builder"></a>Using Interface Builder</h2><ul>
<li><p>结论：在使用IB构建界面的时候，应该使用<strong>弱属性</strong></p>
</li>
<li><p>讨论：</p>
<ul>
<li><p>我们使用IB”画界面”的时候，IB自动为我们生成的代码就是weak的（如下图）</p>
<p>​<img src="/2016/11/22/UIResponder,%20Weak%20Or%20Strong/aWeakIBLabel.png" alt="IBCreatedCode" title="IBCreatedCode"></p>
</li>
<li><p>这是为什么呢？主要是因为我们使用IB设计界面时，View因为是Controller的属性，会被自动持有，而我们在界面设计中的UILabel则被View持有的SubViews的其中一个SubView所持有，即持有关系如下图。</p>
<img src="/2016/11/22/UIResponder,%20Weak%20Or%20Strong/holdingDiagram.png" alt="Holding" title="Holding">
</li>
<li><p>既然aIBLabel已经被最顶层的Controller所持有了，那么，我们再去使用一个同样被Controller所持有强属性aIBLabel去持有UILabel也就变得没有意义了。因为UILabel的生命周期不是由属性aIBLabel去维持的，所以这里我们只需用弱属性指向（见上图），便于后续使用即可</p>
</li>
<li><p>那么我们这里使用强属性会有问题吗?</p>
<ul>
<li>没有问题。当使用强属性指向控件的时候，UILabel的引用计数为2。当Controller释放时，Controller指向的Properties（包含View与aIBLabel属性）也会释放。而他们的释放又会导致UILabel的引用计数下降至0，一切都安全释放，没有问题。不过苹果更加建议我们在IB中使用弱属性，主要原因可能是因为：如果View都被释放了，那View上的控件即使存在，又有什么意义呢?</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Using-Code-Code-Style-1"><a href="#Using-Code-Code-Style-1" class="headerlink" title="Using Code - Code Style 1"></a>Using Code - Code Style 1</h2><ul>
<li><p>结论：在使用代码构建界面的时候，不同的代码风格应当使用不同的持有方式。采用局部变量<strong>创建并立即添加</strong>到View上的控件，可用<strong>弱属性</strong>指向；采用局部变量创建，但出了局部变量作用域后，再延后添加到View上的控件，需用<strong>强属性</strong>指向</p>
</li>
<li><p>讨论：</p>
<ul>
<li><p>第一种代码风格：采用临时变量创建并立即添加控件，采用弱属性指向，代码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readwrite</span>)   <span class="built_in">UILabel</span> *weakLabel;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// Code Style 1:</span></div><div class="line"><span class="built_in">UILabel</span> *aLabel  = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(viewSize.width / <span class="number">2</span> - <span class="number">40</span>, viewSize.height / <span class="number">2</span> - <span class="number">40</span>, <span class="number">80</span>, <span class="number">80</span>)]; <span class="comment">// ①New - retainCount = 1</span></div><div class="line">aLabel.text      = aString;</div><div class="line"><span class="keyword">self</span>.weakLabel   = aLabel; 				<span class="comment">// ②Point To It  - retainCount = 1</span></div><div class="line">[<span class="keyword">self</span>.view addSubview:aLabel]; 			<span class="comment">// ③Add SubView  - retainCount = 2</span></div></pre></td></tr></table></figure>
</li>
<li><p>此时的持有关系图如下</p>
<img src="/2016/11/22/UIResponder,%20Weak%20Or%20Strong/holdingDiagram2.png" alt="Holding Of Code Style 1" title="Holding Of Code Style 1">
</li>
<li><p>UILabel的引用计数</p>
<ol>
<li>局部变量aLabel创建了UILabel，并持有，这个局部变量在出了作用域之后就被内存收回</li>
<li>我们为了方便下文继续引用，使用了一个弱属性指向他（如果下文不需要这个变量，不指向他也是可以的，因为他不会影响对象的生命周期）</li>
<li>把这个UILabel添加到View的Subview上，简单而言，就是View间接持有了这一个UILabel。至此，UILabel才”安全着陆”，哪怕此时局部变量突然因为某些突发情况/出了作用域被收回，UILabel这一块内存也不会被收回（只是引用计数从二将至一罢了）</li>
</ol>
</li>
<li><p>如果我们想要延后添加控件（不立即添加到View上，但依旧使用weakLabel指向他）。在过后某个事件中使用<code>[self.view addSubview:self.weakLabel];</code>添加可以吗?</p>
<ul>
<li>不可以！因为当出了这一块函数作用域后，局部变量aLabel的内存将被收回。此时因为再也没有强属性/变量指向我们创建的UILabel了，所以UILabel的<code>retainCount = 0</code>，UILabel的内存也因此被收回。我们的弱属性weakLabel因为指向的对象已经被释放，所以他将自动将自己设为nil，以避免出现野指针问题。所以我们在后面使用<code>[self.view addSubview:self.weakLabel];</code>时，实际上是向空指针发送消息，在OC中，向空指针发送消息不会被处理，也不会抛出异常，所以一切事情看似”平静”度过了，UILabel也因此没有被添加到View上</li>
</ul>
</li>
<li><p>我们在这里使用强属性指向会有问题吗?</p>
<ul>
<li>没有问题，而且<strong>需要延后添加控件的情况需要使用强属性指向</strong>。当使用强属性指向控件的时候，UILabel的引用计数为2。如果没有使用<code>[self.view addSubview:self.weakLabel];</code>，在出了变量作用范围后（即aLabel已经无法访问）时，引用计数降至一，此时可以在其他方法使用<code>[self.view addSubview:self.weakLabel];</code>延后添加；如果是立即添加，内存亦会被安全释放，理由同上文<em>Using Interface Builder</em>中的强属性指向讨论</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Using-Code-Code-Style-2"><a href="#Using-Code-Code-Style-2" class="headerlink" title="Using Code - Code Style 2"></a>Using Code - Code Style 2</h2><ul>
<li><p>结论：在使用代码构建界面的时候，不同的代码风格应当使用不同的持有方式。直接采用属性创建的控件，应该使用<strong>强属性</strong>指向</p>
</li>
<li><p>讨论：</p>
<ul>
<li><p>第二种代码风格：直接使用属性创建的控件，应用强属性指向，代码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UILabel</span> *strongLabel;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// Code Style 2:</span></div><div class="line"><span class="keyword">self</span>.strongLabel      = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(viewSize.width / <span class="number">2</span> - <span class="number">40</span>, viewSize.height / <span class="number">2</span> - <span class="number">40</span>, <span class="number">80</span>, <span class="number">80</span>)]; <span class="comment">// ①New - retainCount = 1</span></div><div class="line"><span class="keyword">self</span>.strongLabel.text = aString;</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.strongLabel];    <span class="comment">// ②Add SubView  - retainCount = 2</span></div></pre></td></tr></table></figure>
</li>
<li><p>此时的持有关系图如下</p>
<img src="/2016/11/22/UIResponder,%20Weak%20Or%20Strong/holdingDiagram3.png" alt="Holding Of Code Style 2" title="Holding Of Code Style 2">
</li>
<li><p>UILabel的引用计数</p>
<ol>
<li>strongLabel属性创建并持有UILabel控件，strongLabel被Controller所持有，所以在Controller死亡之前，无论strongLabel属性还是UILabel控件的内存，都不会被收回</li>
<li>把这个UILabel添加到View的Subview上，View间接持有了这一个UILabel。此时UILabel控件的引用计数增至二。当Controller死亡时，属性View与属性strongLabel均死亡，直接导致UILabel控件引用计数降至零，UILabel控件安全释放</li>
</ol>
</li>
<li><p>我们在这里使用弱属性指向会有问题吗?</p>
<ul>
<li><p>有！实际上，当你这样做的时候，我们的Xcode就会出现以下提示提醒你不应该这样做了</p>
<blockquote>
<p>Assigning retained object to weak property; object will be released after assignment</p>
</blockquote>
</li>
<li><p>当我们使用weak属性创建UILabel控件的时候，创建确实是成功创建了，然而，引用没有其他强属性/变量指向它，所以他一创建不久，他就自怨自艾的觉得自己没有用，”自尽”了。所以我们采用第二种代码风格的时候，一定要使用强属性进行指向</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>总结：本文讨论了三种不同代码风格指向控件时，应采用的属性内存管理特性，分析如有错误，还望各位指出。一言以蔽之，使用IB构建视图的时候尽量使用强属性，使用代码构建视图的时候尽量使用强属性。</li>
<li>另外个人还有一些小的思考：Code Style 1 与 Code Style 2的区别是什么？我认为：<ul>
<li>第一种代码风格主要秉承”先配置好控件，控件再上”的理念，这样能够减少调用View的setter/getter，某种程度上可能加快了效率（虽然只是一点点）。</li>
<li>第二种代码风格主要秉承”控件先上，其他慢慢来”的理念，这样虽然会大量调用到View的setter/getter，但是在某种程度上，减少了创建局部变量的内存消耗（虽然很少）。</li>
<li>个人的话，比较钟爱第二种方式，至于为什么？无非是因为第二种方式代码量较少罢了，毕竟，代码这东西少一句有可能就少一次Debug :)</li>
</ul>
</li>
<li>本文代码下载<ul>
<li><a href="https://github.com/SeaHub/CodeSample/tree/master/Code/WOSUIResponder" target="_blank" rel="external"><strong>Github Repo - WOSUIResponder</strong></a></li>
<li>运行环境：Xcode 8.1(8B62)</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Last Edited：2016.11.23</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：一个小问题引起的两三思&lt;/p&gt;
    
    </summary>
    
      <category term="ObjC" scheme="http://yoursite.com/categories/ObjC/"/>
    
      <category term="iOS" scheme="http://yoursite.com/categories/ObjC/iOS/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
      <category term="ObjC" scheme="http://yoursite.com/tags/ObjC/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>从小实验探代码优化</title>
    <link href="http://yoursite.com/2016/10/12/%E4%BB%8E%E5%B0%8F%E5%AE%9E%E9%AA%8C%E6%8E%A2%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2016/10/12/从小实验探代码优化/</id>
    <published>2016-10-12T14:45:15.000Z</published>
    <updated>2016-11-01T16:53:58.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：一个C#小实验引起的代码性能探究</p>
<a id="more"></a>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2></li>
<li><p>本文源于一个C#小实验：生成防伪码。与其他以“完成目标”为要求的实验不同，该实验以“性能优化”为要求。实验题目（见下）很简单，简单的数行代码即可实现。而如何让代码达到最佳的性能，即以最短的运行时间运行，成为了我纠结的问题。此处仅以此文记录我的思考过程，望日后有助于同行。</p>
<blockquote>
<ul>
<li>小实验题目：生成防伪码</li>
</ul>
<ol>
<li>防伪码由以下字符组成：0123456789ABCDEFGHJKLMNPQRSTUVWXYZ（数字1和字母I相近、数字0和字母O相近，所以去掉字母I和字母O，全部字母大写）</li>
<li>在命令行中输入2个参数，分别是：防伪码长度与防伪码个数。例如：在命令行中调用程序为“应用程序.exe 10 10000”指的是防伪码长度为10，生成10000个防伪码。</li>
<li>输出结果：时间（单位：ms）</li>
</ol>
<ul>
<li>注意</li>
</ul>
<ol>
<li>不需要输出每个防伪码（在调试时输出防伪码可用于检验生成码的正确性，正式输出时只输出一项结果即运行程序所需要的时间）</li>
<li>防伪码的长度由命令行参数决定</li>
<li>所生成的防伪码不能重复（按照以上例子，生成了10000个防伪码，这10000个防伪码就肯定不能重复）</li>
</ol>
</blockquote>
</li>
<li><p>先贴出公用模板 - 下述其他代码默认嵌套在此模板内执行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// *****************************************************</span></div><div class="line"><span class="comment">// author: @Seahub Seahubc@gmail.com || Seahubc@qq.com</span></div><div class="line"><span class="comment">// 实验一：生成防伪码</span></div><div class="line"><span class="comment">// 防伪码组成元素：0123456789ABCDEFGHIJKLMNPQRSTUVWXYZ</span></div><div class="line"><span class="comment">// input:  防伪码长度 防伪码个数</span></div><div class="line"><span class="comment">// output: 防伪码运行所需时间</span></div><div class="line"><span class="comment">// PS: 防伪码不能重复</span></div><div class="line"><span class="comment">// *****************************************************</span></div><div class="line"><span class="comment">// 测试样例：生成防伪码长度为10，防伪码个数为1,000,000的运算时间</span></div><div class="line"><span class="comment">// 测试环境：Win7 i5-4670T 16GB内存</span></div><div class="line"><span class="comment">// *****************************************************</span></div><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> System.Collections.Generic;</div><div class="line"><span class="keyword">using</span> System.Linq;</div><div class="line"><span class="keyword">using</span> System.Text;</div><div class="line"><span class="keyword">using</span> System.Threading.Tasks;</div><div class="line"><span class="keyword">using</span> System.Diagnostics;</div><div class="line"><span class="keyword">using</span> System.Collections;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">SecurityCode</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">class</span> <span class="title">Program</span></div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// ===================== 固定常量 =====================</span></div><div class="line">            <span class="keyword">const</span> String charArr = <span class="string">"0123456789ABCDEFGHIJKLMNPQRSTUVWXYZ"</span>;</div><div class="line"></div><div class="line">            <span class="comment">// ===================== 获取参数 =====================</span></div><div class="line">            <span class="keyword">int</span> lengthOfSecurityCode = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> numberOfSecurityCode = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (args.Length &lt; <span class="number">2</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 当args带的参数 &lt; 2时，提示输入两个参数</span></div><div class="line">                System.Console.WriteLine(<span class="string">"Please input parameter - "</span> +</div><div class="line">                    <span class="string">"lengthOfSecurityCode:"</span>);</div><div class="line">                lengthOfSecurityCode = Convert.ToInt32(Console.ReadLine());</div><div class="line">                System.Console.WriteLine(<span class="string">"Please input parameter - "</span> +</div><div class="line">                    <span class="string">"numberOfSecurityCode:"</span>);</div><div class="line">                numberOfSecurityCode = Convert.ToInt32(Console.ReadLine());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                lengthOfSecurityCode = <span class="keyword">int</span>.Parse(args[<span class="number">0</span>]);</div><div class="line">                numberOfSecurityCode = <span class="keyword">int</span>.Parse(args[<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// ===================== 开始计时 =====================</span></div><div class="line">            Stopwatch timer = <span class="keyword">new</span> Stopwatch();</div><div class="line">            timer.Start();</div><div class="line">          	</div><div class="line">          	<span class="comment">// ===================== 核心函数 =====================</span></div><div class="line">          	<span class="comment">// toDo - 下述思考过程代码将代替此部分</span></div><div class="line">          </div><div class="line">            <span class="comment">// =================== 停止计时并输出 ==================</span></div><div class="line">            timer.Stop();</div><div class="line">            <span class="keyword">double</span> dMilliseconds = timer.Elapsed.TotalMilliseconds;</div><div class="line">            System.Console.WriteLine(<span class="string">"生成个数为："</span> + numberOfSecurityCode +</div><div class="line">                <span class="string">"，运行时间为："</span> + dMilliseconds + <span class="string">"ms"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><p>思考过程的第一个实现 - 利用HashSet + StringBuilder 简单实现（下述代码代替公用模板toDO部分）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// *****************************************************</span></div><div class="line"><span class="comment">// 测试样例：生成防伪码长度为10，防伪码个数为1,000,000的运算时间</span></div><div class="line"><span class="comment">// 测试环境：Win7 i5-4670T 16GB内存</span></div><div class="line"><span class="comment">// 测试结果：826.5098s</span></div><div class="line"><span class="comment">// *****************************************************</span></div><div class="line">HashSet&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">Random random = <span class="keyword">new</span> Random();</div><div class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(lengthOfSecurityCode);</div><div class="line"></div><div class="line"><span class="keyword">while</span> (result.Count != numberOfSecurityCode)</div><div class="line">&#123;</div><div class="line">	sb.Clear();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthOfSecurityCode; ++i)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 生成一个随机数</span></div><div class="line">		<span class="keyword">int</span> idx = random.Next(<span class="number">0</span>, charArr.Length);</div><div class="line">		sb.Append(charArr[idx]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	result.Add(sb.ToString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码分析</p>
<ul>
<li>思路：利用sb去存储字符组成字符串，因为防伪码不能重复，所以将生成防伪码后加入HashSet</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>思考过程的第二个实现 - HashSet + StringBuilder + 少量优化（下述代码代替公用模板toDO部分）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// *****************************************************</span></div><div class="line"><span class="comment">// 测试样例：生成防伪码长度为10，防伪码个数为1,000,000的运算时间</span></div><div class="line"><span class="comment">// 测试环境：Win7 i5-4670T 16GB内存</span></div><div class="line"><span class="comment">// 测试结果：688.5649ms</span></div><div class="line"><span class="comment">// *****************************************************</span></div><div class="line">HashSet&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">Random random = <span class="keyword">new</span> Random();</div><div class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(lengthOfSecurityCode);</div><div class="line"><span class="keyword">int</span> charArrlength = charArr.Length;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (result.Count != numberOfSecurityCode)</div><div class="line">&#123;</div><div class="line">	sb.Length = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthOfSecurityCode; ++i)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 生成一个随机数</span></div><div class="line">		<span class="keyword">int</span> idx = random.Next(charArrlength);</div><div class="line">		sb.Append(charArr[idx]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	result.Add(sb.ToString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码分析</p>
<ul>
<li>上述代码我的优化如下，下面的数据采用了控制变量进行测量<ul>
<li>优化一：使用了<code>charArrlength</code>代替了<code>charArr.Length</code><ul>
<li>成功优化的原因：避免多次调用</li>
<li>优化结果：<em>减少 715.5070ms -  688.5649ms  = 26.9421ms</em></li>
</ul>
</li>
<li>优化二：使用了<code>random.Next(charArrlength)</code>代替了<code>random.Next(0, charArrlength)</code><ul>
<li>成功优化的原因：未知</li>
<li>优化结果：<em>减少 798.8720ms -  688.5649ms = 110.3071ms</em></li>
</ul>
</li>
<li>优化三：使用了<code>sb.Length = 0</code>代替了<code>sb.clear()</code><ul>
<li>成功优化的原因：未知</li>
<li>优化结果：<em>减少 692.9382ms - 688.5649ms = 4.3733ms</em></li>
</ul>
</li>
</ul>
</li>
<li>一开始我以为对性能优化最多的应该是优化一。没想到却是偶尔一试的优化二使得时间大幅下降，实在是意料之外。奈何自身水平有限，不知道优化二为何能够如此大幅度降低运行时间，猜想应该是<code>random.Next(0, charArrlength)</code>在每次循环内进行了两次判断（一次判断是否大于等于0，一次判断是否小于charArrlength），而random.Next(charArrlength)在每次循环内只判断了上界，所以效率更高。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>思考过程的第三个实现 - HashSet + 变长字符数组（下述代码代替公用模板toDO部分）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// *****************************************************</span></div><div class="line"><span class="comment">// 测试样例：生成防伪码长度为10，防伪码个数为1,000,000的运算时间</span></div><div class="line"><span class="comment">// 测试环境：Win7 i5-4670T 16GB内存</span></div><div class="line"><span class="comment">// 测试结果：627.5172ms</span></div><div class="line"><span class="comment">// *****************************************************</span></div><div class="line">HashSet&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">Random random = <span class="keyword">new</span> Random();</div><div class="line"><span class="keyword">char</span>[] charSb = <span class="keyword">new</span> <span class="keyword">char</span>[lengthOfSecurityCode];</div><div class="line"><span class="keyword">int</span> charArrlength = charArr.Length;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (result.Count != numberOfSecurityCode)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthOfSecurityCode; ++i)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 生成一个随机数</span></div><div class="line">		<span class="keyword">int</span> idx = random.Next(charArrlength);</div><div class="line">		charSb[i] = charArr[idx];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	result.Add(<span class="keyword">new</span> String(charSb));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码分析</p>
<ul>
<li>使用了变长字符数组来代替StringBuilder<ul>
<li>成功优化的原因：字符数组非对象，减少CLI管理内存的时间损耗以及对象生成时间</li>
<li>优化结果：<em>减少 688.5649ms - 627.5172ms = 61.0477ms</em></li>
</ul>
</li>
<li>思考过后，还是觉得论性能，原生数组应该比对象更加有优势，因此最终我采用了本方案</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>总结：在内存冗余的计算机时代，这点性能优化显得微不足道。然而，在我看来，偶尔研究一下性能，能够更加有助于我们不断改进代码，写出更加高效精炼的“好代码”。愿与大家一同做会思考的工程师，而非只是堆代码的码农。</li>
</ul>
<hr>
<ul>
<li>Last Edited：2016.10.13</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：一个C#小实验引起的代码性能探究&lt;/p&gt;
    
    </summary>
    
      <category term="C#" scheme="http://yoursite.com/categories/C/"/>
    
      <category term="代码优化" scheme="http://yoursite.com/categories/C/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Scau防伪码实验" scheme="http://yoursite.com/tags/Scau%E9%98%B2%E4%BC%AA%E7%A0%81%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="代码优化" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>我所理解的小程序</title>
    <link href="http://yoursite.com/2016/10/09/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2016/10/09/我所理解的小程序/</id>
    <published>2016-10-09T00:33:54.000Z</published>
    <updated>2016-11-01T16:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：Hackathon的见闻与微信小程序的真机初体验</p>
<a id="more"></a>
</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>之前一直都很想参加一场真正的黑客马拉松，奈何大部分的国内黑客马拉松都在北上杭，而我作为穷苦的学生党，没有额外的资金买车票去远方追求理想与梦想。所幸，2016年第一场在广州举办的黑客马拉松，我有幸坑了两个朋友（后端玩家Samray、Web前端玩家Nomad），一同参与其中，一天多的专注，让我有幸体验了一下未来的小程序，感触颇多，因记此文。文章前半部分叙述Hackathon相关的内容，后半部分叙述小程序相关的内容，读者若对前半部分不感兴趣，跳过即可。</p>
<hr>
<h4 id="Hackathon"><a href="#Hackathon" class="headerlink" title="Hackathon"></a>Hackathon</h4><blockquote>
<p>Hackathon Place: GuangZhou TIT iFanr</p>
<p>Hackathon Date: 2016.10.7 10:00 - 2016.10.8 15:00</p>
<p>Hackathon Topic: The Future WeChat App</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>Hackathon Pre：</p>
<ul>
<li>本次Hackathon的主题要求是“未来、实用”。我个人感觉这个主题范围十分宽。思考一个多小时后，我们队伍最终选择的Hackathon Project是Pig Raising，创意参考了<a href="http://www.forestapp.cc/" target="_blank" rel="external">Forest</a>：“在一定时间内，限制人们不能触碰手机，否则任务失败”。之所以想到这个创意，是因为我们认为小程序的弊端在于开启小程序后，微信就不能切换到聊天界面（即微信与微信小程序只能保留一个界面）。我们希望通过Pig Raising将这个弊端消除，使用Pig Raising时，目标就是不使用其他程序，所以即使保留一个界面也无妨。</li>
<li>在开始项目前，我们三人只阅读了官方文档，而且我与另外一位朋友（Samray）都没有JavaScript的编程经验，甚至连部分语法都不太清楚，所以这个项目对我们的速学能力有蛮大的要求。</li>
<li>最后我们决定由Nomad负责WXSS、WXML的页面部分编写，我负责JSON、JavaScript的逻辑部分编写，因为项目不需要后端环境，所以Samray负责美工及路演相关的准备。</li>
</ul>
</li>
<li><p>Hackathon In：</p>
<ul>
<li>Hackathon Environment<ul>
<li>感觉我们队伍使用的Hackathon工具相比其他队伍而言，还是比较有优势的，因此稍作讨论，希望能够给其他Hackathon Team稍作参考<ul>
<li>编程环境：macOS Sierra 10.12 + 微信Web开发者工具 + Egret Wing Verison 3.2.0</li>
<li>同步环境：Resilio Sync Version 2.4.0 + Github</li>
<li>环境使用：微信Web开发者工具用于动作调试，Egret Wing 3用于代码编辑 + 界面预览（官方的IDE代码编辑能力实在太差:-( ）。为了省去合并的烦恼，我和Nomad是同时编辑同一个项目下的不同文件（eg：Nomad编辑index.wxss、index.wxml，我编辑index.json、index.js）。也许你会问，不用git/svn，如何同步合并代码？我们使用了Resilio Sync这个小工具。它能够在电脑上创建一块共享盘，供有同步Key的朋友访问。相比于其他工具，它的同步的速度十分快，我们把项目放在了共享盘中，基本上Nomad一编辑完wxss/wxml后几秒，我这边的项目文件中已经能看到最新的代码了。这样的短延迟完全不影响我们的编码，也省去了事后合并的烦恼。Github在我们团队中主要用来存放了一些请求资源，没有起到项目代码控制的作用。</li>
<li>建议：在能够面对面编程的小团队（3-5人）中，感觉直接使用Resilio Sync合并代码更加有优势</li>
</ul>
</li>
</ul>
</li>
<li>Hackathon Coding<ul>
<li>Coding：编程过程是比较枯燥的，Hackathon中后期基本完成主体功能后就感觉十分困了，后期思路也没有前期的清晰。这个项目的难点主要在于主界面的圆圈倒计时上，其次是Pig Farm界面的随机位置选择上，花了不少时间，其他部分都比较容易。编码对于我这个JavaScript小白而言，就是查文档（微信小程序文档 + JavaScript文档 + w3school资料），感觉项目的实现还是比较容易的。</li>
</ul>
</li>
</ul>
</li>
<li><p>Hackathon After：</p>
<ul>
<li>很遗憾，项目没有荣获什么奖。但是我们的队员收获都挺大的，由于iFanr提供了App ID供我们测试，因此我们也有幸感受到微信小程序的未来，以及认识了一群大神。我个人技术的提升，大概可以说是24小时JavaScript从入门到抢月饼 :-）。感觉不错，但是深感自己的JavaScript代码写的很丑，还是得多多阅读实践方可。</li>
</ul>
</li>
<li><p>Pig Raising项目已经开源，有兴趣的朋友可以前往一试 =&gt; <a href="https://github.com/SeaHub/PigRaising" target="_blank" rel="external">传送门</a>  </p>
<pre><code>{% asset_img 1.jpeg  Group Photo %}
</code></pre></li>
</ul>
<hr>
<h4 id="Wechat-App"><a href="#Wechat-App" class="headerlink" title="Wechat App"></a>Wechat App</h4><ul>
<li><p>小程序的开发</p>
<ul>
<li>小程序的开发成本总体而言还是比较低的，即使是像我这样不会Web前端的iOS码农，甚至对JavaScript只是一知半懂的iOS码农也能快速在1~2天内开发出一个小程序（当然，看文档时间另算）。</li>
<li>小程序的权限目前而言感觉还是比较收的比较紧的，很多数据都不能够获取，这也暂时限制了微信小程序的应用前景，希望以后会有所放开。</li>
</ul>
</li>
<li><p>小程序的真机体验</p>
<ul>
<li><p>测试环境</p>
<ul>
<li>iPhone 6S Plus</li>
<li>iOS 10</li>
<li>中速偏慢的Wifi环境</li>
</ul>
</li>
<li><p>谈谈体验：总体而言，真机体验和模拟器体验是不一样的。我个人总结为以下几点：</p>
<ul>
<li>模拟器没有显示微信自动生成的导航栏</li>
<li>模拟器的适配布局有偏移(eg:同样是iPhone 6S Plus，模拟器6SP上的(x, y)坐标与真机6SP上的(x, y)坐标有区别，有少量的偏移)</li>
<li>IDE有部分Bug，模拟器上跑的程序正常，但真机上跑的程序可能会出现Bug</li>
<li>微信小程序1M的真机代码大小限制</li>
</ul>
</li>
<li><p>真机调试的坑</p>
<ul>
<li><p>调试的方法</p>
<ul>
<li>真机调试上也有一个类似模拟器中的控制台，同行们同样可以通过console.log()进行调试。二分法调试(注释 + 输出)应该是目前真机小程序的最好方法了。</li>
</ul>
</li>
<li><p>真机运行图</p>
<ul>
<li>目前真机调试的流程：在微信Web开发者工具中上传代码 =&gt; 官方自动生成一个二维码 =&gt; 只有绑定了该App ID的微信用户能够扫描该二维码 =&gt; 扫描后自动在微信中打开小程序</li>
<li>微信导航栏左上角按钮点击后直接返回微信，右上角按钮点击后出现菜单，菜单包含（控制台，推出，取消等按钮）</li>
</ul>
<img src="/2016/10/09/我所理解的小程序/2.jpeg" alt="App" title="App">
</li>
<li><p>第一次将应用弄到手机上跑的时候，主要遇到了几个神奇的Bug，在此分享一下，避免同行入坑</p>
<ul>
<li><p>Bug 1 - IDE Bug - this.data.status</p>
<ul>
<li><p>Bug 1 Code</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> STATUS_WAITING = <span class="number">0</span> <span class="comment">// 应用开始时状态</span></div><div class="line"><span class="keyword">const</span> STATUS_RUNNING = <span class="number">1</span> <span class="comment">// 应用计时状态</span></div><div class="line"><span class="keyword">const</span> STATUS_COMPLETED = <span class="number">2</span> <span class="comment">// 应用完成状态</span></div><div class="line"></div><div class="line">Page(&#123;</div><div class="line">  data: &#123;</div><div class="line">    <span class="comment">// 计时状态 - 动态</span></div><div class="line">    status: STATUS_WAITING</div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  startTimer: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (status !== STATUS_RUNNING) &#123;</div><div class="line">  		<span class="comment">// Something</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">  		<span class="comment">// Something</span></div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Bug 1 Code Review</p>
<ul>
<li>这段代码仔细分析后，应该可以看出是<code>status</code>写错了，应该使用<code>this.data.status</code>获取。这其实是一个比较简单的小问题，为什么我要抽出来说呢？主要是因为这段在模拟器上是能够正常使用的（即IDE通过编译，运行也是正常的，能够触发后续事件）。但是在真机就会出现明显的Bug（卡死，即无反应）。一般而言，官方IDE在我们没有写<code>this.data</code>时，都是会提醒的，但是不排除像我这种特殊情况。所以，当真机调试出现迷之Bug时，不妨看看是不是这个问题。</li>
</ul>
</li>
<li><p>Bug 1 Correct Code</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> STATUS_WAITING = <span class="number">0</span> <span class="comment">// 应用开始时状态</span></div><div class="line"><span class="keyword">const</span> STATUS_RUNNING = <span class="number">1</span> <span class="comment">// 应用计时状态</span></div><div class="line"><span class="keyword">const</span> STATUS_COMPLETED = <span class="number">2</span> <span class="comment">// 应用完成状态</span></div><div class="line"></div><div class="line">Page(&#123;</div><div class="line">  data: &#123;</div><div class="line">    <span class="comment">// 计时状态 - 动态</span></div><div class="line">    status: STATUS_WAITING</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  startTimer: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.data.status !== STATUS_RUNNING) &#123;</div><div class="line">      <span class="comment">// Something</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Something</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><p>Bug 2 - Layout Change - e.target.offsetTop</p>
<ul>
<li>Bug 2 Code</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action-sheet</span> <span class="attr">hidden</span>=<span class="string">"&#123;&#123;actionSheetHidden&#125;&#125;"</span> <span class="attr">bindchange</span>=<span class="string">"actionSheetChange"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;actionSheetItems&#125;&#125;"</span>&gt;</span></div><div class="line">    	<span class="tag">&lt;<span class="name">action-sheet-item</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">bindtap</span>=<span class="string">"bindItemTap"</span> <span class="attr">data-name</span>=<span class="string">"&#123;&#123;item&#125;&#125;"</span>&gt;</span>&#123;&#123;item&#125;&#125;</div><div class="line">    	<span class="tag">&lt;/<span class="name">action-sheet-item</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">action-sheet-cancel</span> <span class="attr">class</span>=<span class="string">"cancel"</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">action-sheet-cancel</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">action-sheet</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bindItemTap: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> idx = e.target.offsetTop / <span class="number">38</span></div><div class="line">	<span class="comment">// 使用idx去判断点击了actionSheet中哪一个按钮</span></div><div class="line">    <span class="keyword">this</span>.setData(&#123;</div><div class="line">      selectedTime: PIG_TIME[PIG_NAME_ARR[idx]],</div><div class="line">      showTime: PIG_TIME[PIG_NAME_ARR[idx]] + <span class="string">":00"</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Bug 2 Code Review</p>
<ul>
<li>这段代码同样在模拟器上跑的好好的，但是一到真机上就出现Bug（卡死）。后来分析过后主要发现是布局不一样。同样是iPhone 6S Plus，模拟器6SP上的(x, y)坐标与真机6SP上的(x, y)坐标有区别，有少量的偏移。所以，得到的offSet不能被38整除。使用浮点数值作为数组下标值，结果可想而知。actionSheet按钮判断应使用<code>id</code>判断actionSheet的按钮。</li>
</ul>
</li>
<li><p>Bug 2 Correct Code</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">action-sheet</span> <span class="attr">hidden</span>=<span class="string">"&#123;&#123;actionSheetHidden&#125;&#125;"</span> <span class="attr">bindchange</span>=<span class="string">"actionSheetChange"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;actionSheetItems&#125;&#125;"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">action-sheet-item</span> <span class="attr">id</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">bindtap</span>=<span class="string">"bindItemTap"</span> <span class="attr">data-name</span>=<span class="string">"&#123;&#123;item&#125;&#125;"</span>&gt;</span>&#123;&#123;item&#125;&#125;</div><div class="line">		<span class="tag">&lt;/<span class="name">action-sheet-item</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">block</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">action-sheet-cancel</span> <span class="attr">class</span>=<span class="string">"cancel"</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">action-sheet-cancel</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">action-sheet</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bindItemTap: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> idx = e.currentTarget.id</div><div class="line">	<span class="comment">// 使用idx去判断点击了actionSheet中哪一个按钮</span></div><div class="line">    <span class="keyword">this</span>.setData(&#123;</div><div class="line">      selectedTime: PIG_TIME[PIG_NAME_ARR[idx]],</div><div class="line">      showTime: PIG_TIME[PIG_NAME_ARR[idx]] + <span class="string">":00"</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>Bug 3 - 真机代码大小限制<ul>
<li>微信小程序限制了小程序大小为1M以内。而由于我们队伍的小程序有许多资源（音频、图片）等，所以项目文件夹的大小是远远超过了1M的。那怎么办？只有把资源文件放在后端，再进行资源请求。我们把资源放在了Github，然后在使用过程对资源进行了请求，请求后进行缓存，避免二次加载。这样做后，项目文件立刻降到了400多Kb。我觉得代码限制，这个点也是跑模拟器的时候不会注意到的。而对于部分开发者（如打算把Native app完全迁移的朋友），哪怕除去资源文件，我的纯代码就是这么大，微信不给上传，怎么办？我觉得解决方案应该能够参考iOS的热更新，把部分程序放在后端，在实际用到页面后再进行请求。</li>
</ul>
</li>
</ul>
<hr>
</li>
</ul>
</li>
</ul>
</li>
<li><p>小程序的应用前景</p>
<ul>
<li><p>作为一个希望有产品思维的iOS码农，我觉得小程序未来在部分领域是十分有潜力的，下图是我个人比较看好的小程序应用方向。我认为，小程序正正应该是“用完即走”，过多的停留还是应该留给Native App来处理。毕竟，总不可能在微信里面在造一个小微信吧:-P？</p>
<img src="/2016/10/09/我所理解的小程序/3.png" alt="WechatApp Application" title="WechatApp Application">
</li>
<li><p>Wechat App和RN，我个人感觉还是蛮大区别的，RN更多的是应用在Hybrid App中，但Wechat App由于其不能在浏览器中打开，可能更多的还是会自成一派。</p>
</li>
<li><p>最后我想东拼西凑的一段话来结束这篇文章，望博君一笑：</p>
<blockquote>
<p>不懂互联网的普通人往往过高的估算小程序的价值与意义，而懂互联网的程序员往往是低估了小程序的未来价值。在我看来，唯一不变的只有变化，何不拥抱这场变化？Just Kiss The Change！</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Last Edited：2016.10.9</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：Hackathon的见闻与微信小程序的真机初体验&lt;/p&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="WechatApp" scheme="http://yoursite.com/tags/WechatApp/"/>
    
      <category term="Hackathon" scheme="http://yoursite.com/tags/Hackathon/"/>
    
      <category term="iFanr x Segmentfault" scheme="http://yoursite.com/tags/iFanr-x-Segmentfault/"/>
    
  </entry>
  
  <entry>
    <title>在校园网上使用IPv6</title>
    <link href="http://yoursite.com/2016/09/25/%E5%9C%A8%E6%A0%A1%E5%9B%AD%E7%BD%91%E4%B8%8A%E4%BD%BF%E7%94%A8IPv6/"/>
    <id>http://yoursite.com/2016/09/25/在校园网上使用IPv6/</id>
    <published>2016-09-25T14:48:13.000Z</published>
    <updated>2016-11-01T16:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：折腾校园网IPv6的两三事</p>
<a id="more"></a>
<hr>
</li>
<li><p>前言</p>
<ul>
<li>之前一直有听闻校园网能够使用IPv6，奈何不是没时间折腾，就是忘了这件事。最近听周边的朋友研究IPv6的使用，于是掺和折腾了一把。一开始掉进了一个坑，以为有IPv6的地址便可，后来发现还要一些小配置。希望借此文整理一下思路，同时也供后人稍作参考，减少掉坑率。</li>
</ul>
</li>
<li><p>思路</p>
<ol>
<li><p>获取IPv6地址</p>
</li>
<li><p>设置IPv6 DNS</p>
</li>
<li><p>修改hosts文件的域名-地址映射关系，使得访问域名时优先访问IPv6的地址，否则每次都要请求DNS</p>
<blockquote>
<p>hosts知识补充：Hosts 文件本来是用来提高解析效率。在进行 DNS 请求以前，系统会先检查自己的 Hosts 文件中是否有这个地址映射关系，如果有则调用这个 IP 地址映射，如果没有再向已知的 DNS 服务器提出域名解析。也就是说 Hosts 的请求级别比 DNS 高。当你的 Hosts 文件里面有对应的 IP 时，它就会直接访问那个 IP，而不用通过 DNS。</p>
<p>作者：Wildog<br>来源：<a href="https://www.zhihu.com/question/19782572/answer/12946786" target="_blank" rel="external">知乎 - 修改 hosts 文件的原理是什么?</a></p>
</blockquote>
</li>
</ol>
</li>
<li><p>测试环境</p>
<ul>
<li>macOS Sierra 10.12</li>
<li>SCAU Education Net</li>
<li>极路由固件版本 1.0.7.13499s</li>
</ul>
</li>
<li><p>实操</p>
<ol>
<li><p>获取IPv6地址</p>
<ol>
<li><p>登录极路由后台, 后台默认密码: admin/wifi密码</p>
<ul>
<li><p><a href="http://www.4006024680.com/" target="_blank" rel="external">极路由后台登录</a></p>
</li>
<li><p>点击智能插件 - 安装插件 - 教育网IPv6</p>
<img src="/2016/09/25/在校园网上使用IPv6/1.png" alt="IPv6 Plugin Installing" title="IPv6 Plugin Installing">
</li>
</ul>
</li>
<li><p>配置插件 - 更改接入方式为IPv6中继（具体视不同高校进行不同设置）</p>
<img src="/2016/09/25/在校园网上使用IPv6/2.png" alt="IPv6 Plugin Settings" title="IPv6 Plugin Settings">
</li>
<li><p>重启路由器</p>
</li>
<li><p>重新进入路由器后台 - 点击系统设置 - 查看是否成功获取了IPv6地址</p>
<img src="/2016/09/25/在校园网上使用IPv6/3.png" alt="IPv6 Address" title="IPv6 Address">
</li>
</ol>
</li>
<li><p>设置IPv6 DNS</p>
<ol>
<li>更改本机首选DNS为谷歌IPv6 DNS<ul>
<li>谷歌IPv6 DNS1：2001:4860:4860::8888</li>
<li>谷歌IPv6 DNS2：2001:4860:4860::8844</li>
<li>DNS修改方式<ul>
<li><a href="http://jingyan.baidu.com/article/fc07f9891f626712ffe519cf.html" target="_blank" rel="external">macOS</a></li>
<li><a href="http://jingyan.baidu.com/article/f71d60375584591ab641d13c.html" target="_blank" rel="external">windows</a></li>
<li><a href="http://jingyan.baidu.com/article/870c6fc32c028eb03fe4be30.html" target="_blank" rel="external">linux</a></li>
</ul>
</li>
</ul>
</li>
<li><p>登录<a href="http://test-ipv6.com/" target="_blank" rel="external">Test-IPv6</a>网站进行测试，是否成功进行了配置</p>
<ul>
<li><p>若得到的不是类似下图的页面，请检查IPv6地址与IPv6 DNS是否成功设置</p>
<img src="/2016/09/25/在校园网上使用IPv6/4.png" alt="IPv6 Testing" title="IPv6 Testing">
</li>
</ul>
</li>
</ol>
</li>
<li><p>更改hosts</p>
<ol>
<li><p>上网获取hosts（这里个人推荐：<a href="https://serve.netsh.org/pub/ipv6-hosts/" target="_blank" rel="external">奶齿NetSh</a>，选择所需要的IPv6地址后即可下载)</p>
</li>
<li><p>经常使用百度云盘的用户，建议在下载的hosts文件中，再增加以下hosts，以IPv6的方式逃离限速百度云的魔爪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#Baiducloud</div><div class="line">2400:da00::dbf:0:6666 p.baidupcs.com</div><div class="line">2400:da00::dbf:0:6666 nj.baidupcs.com</div><div class="line">2400:da00::dbf:0:6666 qd.baidupcs.com</div><div class="line">2400:da00::dbf:0:6666 cdn.baidupcs.com</div><div class="line">2400:da00::dbf:0:6666 hot.baidupcs.com</div><div class="line">2400:da00::dbf:0:6666 www.baidupcs.com</div><div class="line">2400:da00::dbf:0:6666 hot.cdn.baidupcs.com</div><div class="line">2400:da00::dbf:0:6666 d.pcs.baidu.com</div><div class="line">#END baiducloud</div></pre></td></tr></table></figure>
</li>
<li><p>登录<a href="www.google.com">谷歌</a>，测试是否成功配置</p>
</li>
</ol>
</li>
<li><p>Enjoy!</p>
<ul>
<li><p>下图为SCAU IPv6的平均网速</p>
<img src="/2016/09/25/在校园网上使用IPv6/5.png" alt="IPv6 Showing" title="IPv6 Showing">
</li>
</ul>
</li>
</ol>
</li>
<li><p>后记</p>
<ul>
<li><p>在使用了IPv6后，第一个感觉就是苹果的服务明显快了。以前通过shadowsocks/VPN/8.8.8.8，延迟感觉还是颇高，下载速率也普遍维持在500KB/s左右。用了IPv6后，平均下载速度大概为1.5M/s，速率提升之大实在令人感慨。</p>
</li>
<li><p>本文中提及的方法都是本人所采用的方法，只具有参考意义。大家也可以通过其他方法获得IPv6的地址（比如SCAU还能通过网线直连电脑的方式获得IPv6地址）。本文，仅作参考。</p>
</li>
</ul>
<hr>
<ul>
<li>Last Edited：2016.9.25</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：折腾校园网IPv6的两三事&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
      <category term="SCAU" scheme="http://yoursite.com/tags/SCAU/"/>
    
      <category term="IPv6" scheme="http://yoursite.com/tags/IPv6/"/>
    
      <category term="校园网" scheme="http://yoursite.com/tags/%E6%A0%A1%E5%9B%AD%E7%BD%91/"/>
    
      <category term="教育网" scheme="http://yoursite.com/tags/%E6%95%99%E8%82%B2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello, My Blog</title>
    <link href="http://yoursite.com/2016/09/17/HelloMyBlog/"/>
    <id>http://yoursite.com/2016/09/17/HelloMyBlog/</id>
    <published>2016-09-17T12:19:43.000Z</published>
    <updated>2016-11-22T14:19:51.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>摘要：开博客的原因以及一些个人感触</p>
<a id="more"></a>
<hr>
<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><ul>
<li>自从上大学以来，每天都在接触新的知识。学得越多，让我感觉不会的也就越多。学得虽多，但是由于日常性情懒惰，闲于整理，故一直对许多知识结构不是十分清楚。希望借助本博客，整理好自己的学习体系，逐渐提高自己对知识的整体把握度。</li>
</ul>
<h2 id="CodeVs-系列介绍"><a href="#CodeVs-系列介绍" class="headerlink" title="CodeVs 系列介绍"></a>CodeVs 系列介绍</h2><ul>
<li><p>Q1：这个系列是什么？</p>
<blockquote>
<ul>
<li><p>我对CodeVs系列的定义：通过对框架 / 语言 / 思想进行比较，将已有的知识体系迁移到正在学习的知识体系上，在学习新知识的同时，对旧知识进行重温。</p>
</li>
<li><p>每篇CodeVs系列文章开始前会有一个文章说明，如下：</p>
<ul>
<li><p>CodeVs Header</p>
<ul>
<li><p>CodeVs Version</p>
<p>// 当前的版本号 - 每一次大修改我都会更改版本号 - 默认版本号为1.0</p>
<ul>
<li>Old =&gt; New            </li>
</ul>
<p>// 旧体系为Old，新体系为New，该文讲述如何以旧体系的角度理解新体系</p>
</li>
<li><p>Acticle Related Knowledge </p>
<p>// 该文对比的知识点</p>
</li>
<li><p>Old Environment</p>
<p>// 旧体系的编程环境 - 该文旧体系的代码保证能在该编程环境正常编译、运行</p>
</li>
<li><p>New Environment</p>
<p>// 新体系的编程环境 - 该文新体系的代码保证能在该编程环境正常编译、运行</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>Q2：为什么会有这个系列？</p>
<blockquote>
<ul>
<li>这个系列源于个人的学习感触。个人而言，很多知识点，在项目需要时，是掌握的。但一当项目完结或在一段时间不用该框架、语言、思维方式编程而转用另外的新体系时，可能过了不久，我们对旧体系的掌握度就逐渐下降，乃至陌生。</li>
<li>这个感触在我大二升大三这一阶段尤为深刻。由于课业、项目需要，学了不少语言，诸如Java、Python等。陆陆续续，语言越学越多，直到现在，我对Java、Python的能力，也就仅限于“勉强能读”的阶段了，这也许就是所谓的最熟悉的陌生人。</li>
<li>为了避免再次见到陌生人，故作此系列以在学习新知识的同时，对旧知识进行比较与重温。</li>
</ul>
</blockquote>
</li>
<li><p>Q3：这个系列会持续多久？</p>
<blockquote>
<ul>
<li>这个问题不好答。这一次，我给自己挖的坑很大，我会断断续续更新该系列的文章，愿该系列不断陪伴着我成长。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="博客相关"><a href="#博客相关" class="headerlink" title="博客相关"></a>博客相关</h2><ul>
<li>博客内容均为原创，若文章中有相关的参考资料，将会以引用方式标注参考内容的作者、并标明原作者以及原链接，以引导读者进一步阅读更多相关资料<ul>
<li>博客每篇文章最底部会有一个”Last Edited”表示文章的最后修订状态</li>
<li>修订一般为内容的修正，代码风格的更新等</li>
<li>特别重要的修订将会在文章标题标注 / 以补充文章的形式出现</li>
</ul>
</li>
<li>作者：@Seahub</li>
<li>QQEmail：Seahubc@qq.com</li>
<li>Gmail：Seahubc@gmail.com</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Last Edited：2016.11.2</li>
<li>Author：@Seahub</li>
<li>Please <a href="Seahubc@qq.com">contact me</a> if you want to share this Article, 3Q~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;摘要：开博客的原因以及一些个人感触&lt;/p&gt;
    
    </summary>
    
      <category term="小记" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="Seahub" scheme="http://yoursite.com/tags/Seahub/"/>
    
  </entry>
  
</feed>
